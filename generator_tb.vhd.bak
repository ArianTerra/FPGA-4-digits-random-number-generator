library ieee;
use ieee.std_logic_1164.all;

entity generator_tb is
end entity;

architecture rtl of generator_tb is
	component generator is
		generic (
        init_seed:  std_logic_vector(31 downto 0);
        force_const_mul: boolean 
		);
    port (
        clk:        in  std_logic;
        -- Synchronous reset, active high.
        rst:        in  std_logic;
        -- High to re-seed the generator (works regardless of enable signal).
        reseed:     in  std_logic;
        -- New seed value (must be valid when reseed = '1').
        newseed:    in  std_logic_vector(31 downto 0);
        -- High when the user accepts the current random data word
        -- and requests new random data for the next clock cycle.
        out_ready:  in  std_logic;
        -- High when valid random data is available on the output.
        -- This signal is low during the first 4*624 clock cycles after
        -- reset and after re-seeding, and high in all other cases.
        out_valid:  out std_logic;
        -- Random output data (valid when out_valid = '1').
        -- A new random word appears after every rising clock edge
        -- where out_ready = '1'.
        data_out:   out std_logic_vector(15 downto 0) 
	);
	end component;
	
	signal clk, reset : std_logic := '0';


begin
	inst0 : six_state_moore_state_machine port map(clk, );
	--input
	process
	begin
		
	end process;
end rtl;